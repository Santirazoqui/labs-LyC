PDefs.   Program ::= [Def] ;
rules Body ::= "{" [Stm] "}" | ";" ;

DVarDecl.    Def   ::= Decl ";" ;
DFun.        Def   ::= Type Id "(" [Arg] ")" Body;
DInlineFun.  Def   ::= "inline" Type Id "(" [Arg] ")" Body ;
DUsing.      Def   ::= "using" Type ";" ;
DTypeDef.    Def   ::= TypeDef ;
DStruct.     Def   ::= StructDef ";";
terminator Def "" ;

XDecl.      Decl  ::= Type [IdSpec] MaybeAss;
XStruct.    StructDef ::= "struct" Id "{" [Decl] "}";
XTypeDef.   TypeDef ::= "typedef" Type Id ";" ;
XStructDef. TypeDef ::= "typedef" StructDef Id ";" ;
terminator Decl ";" ;

rules Arg ::= Type | Type Id MaybeAss ;
separator Arg "," ;

rules IdSpec ::= Id | Id "[" Integer "]";
separator nonempty IdSpec "," ;

SEmpty.      Stm ::= ";" ;
SExp.        Stm ::= Exp ";" ;
SDecls.      Stm ::= Decl ";";
SReturn.     Stm ::= "return" ";" ;
SReturnVal.  Stm ::= "return" Exp ";" ;
SWhile.      Stm ::= "while" "(" Exp ")" Stm ;
SDoWhile.    Stm ::= "do" Stm "while" "(" Exp ")";
SFor.        Stm ::= "for" "(" Decl ";" Exp ";" Exp ")" Stm ;
SForInit.    Stm ::= "for" "(" Exp3 "=" Exp2 ";" Exp ";" Exp ")" Stm ;
SBlock.      Stm ::= "{" [Stm] "}" ;
STypeDef.    Stm ::= TypeDef ;
SIf.         Stm ::= "if" "(" Exp ")" Stm ;
SIfElse.     Stm ::= "if" "(" Exp ")" Stm "else" Stm ;
SStructDef.  Stm ::= StructDef ";";
terminator Stm "" ;

ETrue.   Exp16  ::= "true" ;
EFalse.  Exp16  ::= "false" ;
EInt.    Exp16  ::= Integer ;
EDouble. Exp16  ::= Double ;
EChar.   Exp16  ::= Char ;
EId.     Exp16  ::= [ConstantName] ; 
EString. Exp16  ::= [String] ;
separator nonempty String "" ;

EIndex.  Exp15  ::= Exp15 "[" Exp "]" ; 
EApp.    Exp15  ::= Exp15 "(" [Exp] ")" ;

EDot.    Exp14  ::= Exp14 "." Exp15 ;
EMember. Exp14  ::= Exp14 "->" Exp15 ;
EPIncr.  Exp14  ::= Exp15 "++" ;
EPDecr.  Exp14  ::= Exp15 "--" ;
EDeref.  Exp14  ::= "*" Exp15 ;

EIncr.   Exp13  ::= "++" Exp14 ;
EDecr.   Exp13  ::= "--" Exp14 ;
ENeg.    Exp13  ::= "!" Exp14 ;

ETimes.  Exp12  ::= Exp12 "*"  Exp13 ;
EDiv.    Exp12  ::= Exp12 "/"  Exp13 ;
EMod.    Exp12  ::= Exp12 "%"  Exp13 ;

EPlus.   Exp11  ::= Exp11 "+"  Exp12 ;
EMinus.  Exp11  ::= Exp11 "-"  Exp12 ;

ELShift. Exp10  ::= Exp10 "<<" Exp11 ;
ERShift. Exp10  ::= Exp10 ">>" Exp11 ;

ELt.     Exp9   ::= Exp9 "<"  Exp10 ;
EGt.     Exp9   ::= Exp9 ">"  Exp10 ;
ELe.     Exp9   ::= Exp9 "<=" Exp10 ;
EGe.     Exp9   ::= Exp9 ">=" Exp10 ;
EEq.     Exp8   ::= Exp8 "==" Exp9 ;
ENeq.    Exp8   ::= Exp8 "!=" Exp9 ;
EAnd.    Exp4   ::= Exp4 "&&" Exp5 ;
EOr.     Exp3   ::= Exp3 "||" Exp4 ;
EAss.    Exp2   ::= Exp3 "=" Exp2 ; -- NB: Exp3 podría no ser un lvalue
EAddAss. Exp2   ::= Exp3 "+=" Exp2 ;
ESubAss. Exp2   ::= Exp3 "-=" Exp2 ;
ECond.   Exp2   ::= Exp3 "?" Exp ":" Exp2 ;
EThrow.  Exp1   ::= "throw" Exp2 ;
internal ETyped. Exp16 ::= "(" Exp ":" Type ")" ;
coercions Exp 16 ;
separator Exp "," ;

-- Identificadores
CNIdentifier.            ConstantName ::= Id ;
CNTemplateInstantiation. ConstantName ::= Id "<" [Type] ">" ;
separator nonempty ConstantName "::" ;

-- Tipos, pensándolos de forma similar a las expresiones nos da
-- todas las combinaciones válidas de &, [] y const
rules Type4 ::= "bool" | "double" | "int" | "void" ;
rules Type3 ::= Type4 | [ConstantName] ;
rules Type2 ::= Type3 | Type2 "[]" ;
rules Type1 ::= Type2 | Type2 "&" ;
rules Type  ::= Type1 | "const" Type1 ;
separator nonempty Type "," ;

token Id (letter (letter | digit | '_')*) ;
rules MaybeAss ::= "=" Exp | ;

comment "#" ;
comment "//" ;
comment "/*" "*/" ;
